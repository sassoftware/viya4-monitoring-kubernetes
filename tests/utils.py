from robot.utils import asserts
from robot.output import LOGGER, Message
from os import getenv, environ, path
import subprocess
import sys
import requests
import json
import re

class LoggingUtil(object):
    def __init__(self, run_in_robot, filename=False):
        self.stdout = False if run_in_robot else True # log to console if running outside the framework
        self.filename = filename if filename else getenv("LOG_FILENAME") # self.filename either equals the filename or None
        self.log_msg = self.logToFile if self.filename else self.log_robot_msg # If there is a filename, log to it.
    
    def trace(self, msg):
        """
        Logs a trace message.

        @param msg: Trace message.
        """
        self.log_msg(msg, "TRACE")
    
    def debug(self, msg):
        """
        Logs a debug message.

        @param msg: Debug message.
        """
        self.log_msg(msg, "DEBUG")
    
    def info(self, msg):
        """
        Logs an informational message.

        @param msg: Informational message.
        """
        self.log_msg(msg, "INFO")
    
    def html(self, msg):
        """
        Logs message with same priority as INFO (but makes the
        message safe for html reports").

        @param msg: Message for html reports.
        """
        self.log_msg(msg, "HTML")
    
    def warn(self, msg):
        """
        Logs warning message.

        @param msg: Warning message.
        """
        self.log_msg(msg, "WARN")
    
    def fail(self, msg):
        """
        Logs failure message.

        @param msg: Failure message.
        """
        self.log_msg(msg, "FAIL")
    
    def error(self, msg):
        """
        Logs error message.

        @param msg: Error message.
        """
        self.log_msg(msg, "ERROR")
    
    def log_robot_msg(self, msg, level="DEBUG"):
        """
        This is taken from the robot Built-In library, refer to that for documentation.
        (Per Built-In Library: "Valid levels are TRACE, DEBUG, INFO (default), HTML and WARN.")

        @param msg: Message.
        @param level: Message classification (e.g. info, debug).
        """
        levels = ["TRACE", "DEBUG", "INFO", "HTML", "WARN", "FAIL", "ERROR"]
        if not(level in levels):
            raise Exception("log_robot_msg called with invalid level %s" % level)
        if self.stdout:
            print(level + ": " + str(msg))
        else:
            LOGGER.log_message(Message(msg, level))
    
    def logToFile(self, msg, level="DEBUG"):
        """
        Logs message to file (currently an autogenerated name tmp_log_file).

        You can specify where the log file is created by setting the path as the
        environment variable LOG_FILENAME

        @param msg: Message.
        @param level: Message classification (e.g. info, debug).
        """
        # If the filename is passed as a parameter, then write to the file and exit
        # if fileName is not None:
        #     file = open(fileName, 'a')
        #     file.write("%s: %s\n" % (level, msg))
        #     file.close()
        #     return
        
        # Search for the filename env variable. If it isn't there, create it
        #if "LOG_FILENAME" in environ:
        #    file_name = environ['LOG_FILENAME']
        #else:
        #    time = datetime.now().strftime("%Y-%m-%d-%H:%M:%S")
        #    file_name = '/tmp/automation_{}.txt'.format(time)
        #    environ['LOG_FILENAME'] = file_name
        
        with open("tmp_log_file", 'a') as log:
            log.write("%s: %s\n" % (level, msg))


class BaseTest(object):
    def __init__(self, run_in_robot):
        self.robot_run = True if run_in_robot == "True" else False
        self.log = LoggingUtil(self.robot_run)
        self.http_get = getattr(requests, 'get')
        self.http_post = getattr(requests, 'post')
        self.viya_namespace = environ.get("VIYA_NS")
        self.monitoring_namespace = environ.get("V4M_MON_NS", "monitoring")
        self.logging_namespace = environ.get("V4M_LOG_NS", "logging")
        self.v4m_repo = environ.get("V4M_REPO")
        self.test_repo = environ.get("TEST_REPO")
        self.auto_repo = environ.get("AUTO_REPO")
        self.cert_repo = environ.get("CERT_REPO")
        self.host = environ.get("INGRESS_HOST")
        self.data_dir = self.test_repo + "/data"
        self.log_dir = environ.get("LOG_DIR")
        self.log_file = self.log_dir + "/unit_command_output.log"
        self.cloud_platform = environ.get("CLOUD_PLATFORM")
        self.ops_acr = "ops4viya.azurecr.io"
        self.acr_app_id = environ.get("OPS_ACR_ID")
        self.acr_app_secret = environ.get("OPS_ACR_SECRET")
        self.grafana_url = None
        self.osd_url = None
        self._extract_endpoint_urls()

    def _error_exit(self, message): # Exception has occurred that can't be handled
        _, val, _ = sys.exc_info()
        msg = str(val)
        self.log.error(message)
        self.log.error(msg)
        raise RuntimeError(message)

    def _failure_exit(self, message=None):
        if message is None:
            _, val, _ = sys.exc_info()
            msg = str(val)
        else:
            msg = message
        self.log.fail(msg)
        asserts.fail(msg)
    # Below here are the utility commands
    def _rest_get(self, endpoint, expected_status=None, auth=None, headers=None, timeout=100, files=None, verify=False, stream=None, proxies=None):
        if not verify:
            requests.urllib3.disable_warnings(requests.urllib3.exceptions.InsecureRequestWarning)
        
        self.log.info("request endpoint: " + endpoint)
        self.log.debug("request auth: " + str(auth))
        self.log.debug("request headers: " + str(headers))
        self.log.debug("expected response status code: " + str(expected_status))
        if proxies != None: self.log.debug("using proxy: " + proxies["http"])
        
        response = self.http_get(endpoint, auth=auth, headers=headers, timeout=timeout, files=files, verify=verify, stream=stream, proxies=proxies)
        
        if expected_status is not None and response.status_code != expected_status: # expected status code provided, and it didn't match actual status
            self.log.warn("Bad response: retrying request...")
            response = self.http_get(endpoint, auth=auth, headers=headers, timeout=timeout, files=files, verify=verify, stream=stream, proxies=proxies)
        
        self.log.info("response status code: " + str(response.status_code))
        self.log.debug("response headers:\n" + str(response.headers))
        self.log.trace("response body:\n" + str(response.content))
        return response

    def _rest_post(self, endpoint, data, expected_status=None, auth=None, headers=None, timeout=100, files=None, verify=False, stream=None, proxies=None):
        if verify==False:
            requests.urllib3.disable_warnings(requests.urllib3.exceptions.InsecureRequestWarning)
        
        self.log.info("request endpoint: " + endpoint)
        self.log.debug("request auth: " + str(auth))
        self.log.debug("request headers: " + str(headers))
        self.log.debug("expected response status code: " + str(expected_status))
        if proxies != None: self.log.debug("using proxy: " + proxies["http"])
        
        response = self.http_post(endpoint, data=data, auth=auth, headers=headers, timeout=timeout, files=files, verify=verify, stream=stream, proxies=proxies)
        
        if expected_status is not None and response.status_code != expected_status: # expected status code provided, and it didn't match actual status
            self.log.warn("Bad response: retrying request...")
            response = self.http_post(endpoint, data=data, auth=auth, headers=headers, timeout=timeout, files=files, verify=verify, stream=stream, proxies=proxies)
        
        self.log.info("response status code: " + str(response.status_code))
        self.log.debug("response headers:\n" + str(response.headers))
        self.log.trace("response body:\n" + str(response.content))
        return response

    def _basic_call(self, command, redirect=False):
        stderr = subprocess.STDOUT if redirect else subprocess.PIPE
        try:
            call = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=stderr, stdin=subprocess.PIPE)
            out, err = call.communicate() # waits for call to complete
            rc = call.returncode
        except:
            self.log.warn("Command execution has failed: " + str(command))
            _, val, _ = sys.exc_info()
            self.log.warn("Command error: " + str(val))
            raise
        err = None if err is None else err.decode('utf-8')
        out = out.decode('utf-8')
        try:
            self.log_file
        except AttributeError:
            self.log.debug("self.log_file not set, writing command logs to current directory")
            self.log_file = "basic_command_output.log"
        with open(self.log_file, "a", encoding="utf-8") as log:
            log.write("\nRunning command: " + str(command))
            log.write("\nCommand output: \n")
            log.write(out)
            if err is not None:
                log.write("\n" + err)
            log.write("\nReturncode: " + str(rc))
        return (out, err, rc)

    def _safe_call(self, command, redirect=False):
        stdout, stderr, rc = self._basic_call(command, redirect)
        if rc != 0:
            self.log.error(stdout) if redirect else self.log.error(stderr)
            raise RuntimeError("Error: command " + str(command) + " failed with return code " + str(rc))
        return stdout

    def _call(self, command):
        out, err, rc = self._basic_call(command)
        return out.splitlines(), err.splitlines(), rc

    def _extract_endpoint_urls(self):
        if path.exists(self.data_dir + '/process_logs.json'):
            self._load_process_logs()
            if 'logging_install' in self.process_logs:
                log_list = self.process_logs['logging_install']
                try:
                    self.osd_url = log_list[log_list.index("You can access OpenSearch Dashboards via the following URL:") + 1]
                except ValueError:
                    self.log.warn("Logging install logs available but could not parse OSD URL")

            if 'monitoring_install' in self.process_logs:
                monitor_list = self.process_logs['monitoring_install']
                try:
                    self.grafana_url = monitor_list[monitor_list.index("GRAFANA:") + 1]
                except ValueError:
                    self.log.warn("Monitoring install logs available but could not parse Grafana URL")
        else:
            self.log.info("Process logs were not available, skipping endpoint URL parsing.")

    def _load_process_logs(self):
        """This method loads the process logs from the most recent process
            run during a single testing session.
        
        :output: self.process_logs : dictionary
            The logs from each script are stored as a list in the dictionary
        :output: monitoring_install : list
        :output: logging_install : list
        :output: namespace_install : list
        :output: monitoring_remove : list
        :output: logging_remove : list
        :output: namespace_remove : list
        :output: monitoring_certs : list
        :output: logging_certs : list
        
        :output: self.process_rcs : dictionary
            The return code from each script are stored as an integer in the dictionary
        :output: monitoring_install : integer
        :output: logging_install : integer
        :output: namespace_install : integer
        :output: monitoring_remove : integer
        :output: logging_remove : integer
        :output: namespace_remove : integer
        :output: monitoring_certs : integer
        :output: logging_certs : integer
        """
        self.log.trace("Importing process logs")
        with open(self.data_dir + '/process_logs.json') as process_json:
            self.process_logs = json.loads(process_json.read())
        
        self.log.trace("Importing process return codes")
        with open(self.data_dir + '/process_rcs.json') as process_rc:
            self.process_rcs = json.loads(process_rc.read())

    def _process_log_contains(self, search_term, log_name):
        """This convenience searches a specified process log (output)
            for the given search term.
        
        :param: search_term : string
            The term (or regex) to look for in the selected process log
        :param: log_name : string
            The key for the process log to search in
        
        :output: boolean
            True if the search term was found in the process log
        """
        for line in self.process_logs[log_name]:
            if re.search(search_term, line): return True
        return False
